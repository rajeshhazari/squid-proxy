import groovy.json.JsonSlurper;

def readAppInfoFromJson() {
    def workspacePath = pwd()
    def slurper = new JsonSlurper()
    def json = slurper.parseText(new File("${WORKSPACE}/response.json").text)
    def status = json.status
    return status
}

def runDockerImageWithCommands(image, command, args, version, dir ){
    def dockerImage = script.docker.image("""${image}:${version}""");
    dockerImage.pull();
    dockerImage.inside(' -v ${dir}:/opt/apps/ --entrypoint """'){
        this.runCommand(command, args)
    }
}

def runCommand(cmd, args){
    def paramsArr = []
    for (param in paramsArr){
        paramsArr.add(""" --${param.key}  '${param.value}'""")
    }
    def params = paramsArr.join( ' ')
    script.echo """ running script  ${cmd}  with params  ${params} """
    script.sh(""" ${cmd}  ${params} """)

}

def checkApiContainerHealthStatus( cid , purge){
    response=script.sh(" docker inspect --format='{{json .State.Health}}'  ${cid} ")
    // echo "response code: $http_response"
    if ($response != "0" ) {
        println("Container is not healthy");
        exit 1
    } else {
        println("Container is healthy");
        return true;
    }
}

def getEnvContainerIdForName( name , env) {
    return script.sh(" docker ps -aqf 'name=^${name}-${env}' ");
}

pipeline {
    agent any
    options {
        skipStagesAfterUnstable()
    }
    environment {
    // No environment variables specified
        CI = 'true';
        APPLICATION = 'WebSquidProxy'
        HEALTHCHECK_URL="api/health"
        
    }
    parameters {
        booleanParam(defaultValue: true, description: 'Deploy', name: 'deploy')
        string(defaultValue: "angular9-ts-branch1", description: 'Branch to build', name: 'BRANCH_NAME')

    }
    stages {
            stage('Init') {
            steps {
                /* 
                        script {
                        def common = load("ci/defaults.groovy");
                        common.cancelPreviousBuilds();
                        }
                */
                sh '''
                    VERSION=$(exec node -p "require('./package.json').version")
                    APPLICATION=$(exec node -p "require('./package.json').name")
                    if -z $VERSION
                        then
                        VERSION=1.0.0
                    fi
                    if -z $APPLICATION
                        then
                        APPLICATION=WebSquidProxy
                    fi
                    TAG=${APPLICATION}:${VERSION}
                    VERSION=$VERSION-$(date +"%m%d%Y%M")
                    echo "${APPLICATION}:${VERSION}  TAG:: ${TAG} can now be built"
                    if [ -d ${WORKSPACE}/../ssl ]; then
                    
                        ls -lrth ${WORKSPACE}/../ssl  
                        
                    else 
                        mkdir -pv ${WORKSPACE}/../ssl
                        cd ${WORKSPACE}/../ssl
                        openssl req -x509 -newkey rsa:4096 -sha256 -days 3650 -nodes   -keyout devappserver.key -out devappserver.crt     -subj "/CN=devappserver-api.home.net"      -addext "subjectAltName=DNS:devappserver-api.home.net,DNS:devappserver-api,IP:192.168.0.1/24.192.168.0.23,IP:92.62.66.68"
                        pwd
                        ls -lrth
                        cd ${WORKSPACE}
                    fi
                    
                    
                    '''
            }
            }
        stage('Checkout') {
            steps{
                println('Branch name::'+params.BRANCH_NAME)
                checkout scm
                checkout([$class: 'GitSCM', branches: [[name: '${BRANCH_NAME}'], [name: '**/angular9-ts-branch1']], doGenerateSubmoduleConfigurations: false,
                          extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'RH-Transcribe-app-github-creds', url: 'https://github.com/rajeshhazari/squid-proxy.git']]])
                sh ''' 
                    if [[ -d ${WORKSPACE}/CICD && -d ${WORKSPACE}/CICD/scripts ]]; then
                        chmod +x ${WORKSPACE}/CICD/scripts/*.sh  
                    fi
                    '''
            }
        }
        stage("Get latest git tag") {
            when {
                expression {
                    return (params.BRANCH_NAME == 'master')
                }

            }
            steps{
                script{
                    if (params.BRANCH_NAME == 'master') {
                        sh 'git fetch --tags'
                        TAGGED_COMMIT = sh(script: 'git rev-list --branches=master --tags --max-count=1', returnStdout: true).trim()
                        LATEST_TAG = sh(script: 'git describe --abbrev=0 --tags ${TAGGED_COMMIT}', returnStdout: true).trim()
                        //env.VERSION = sh(script: "echo ${LATEST_TAG} | cut -d 'v' -f 2", returnStdout: true).trim()
                        echo "VERSION: ${VERSION}"
                        
                    }
                }
            }

        }
        stage('Build') {
            steps {
                deleteDir()
                sh '''
                    mkdir ${WORKSPACE}/ssl
                    cp ${WORKSPACE}/../ssl/*  ${WORKSPACE}/ssl/
                    ls -lrth ${WORKSPACE}/ssl/
                    cd ${WORKSPACE}/CICD
                    docker build  --tag ${APPLICATION}:${VERSION} .
                    
                    '''
            }
        }
        stage('Test') {
            steps {
                sh 'node --version'
            }
        }
        stage('deploy') {
            when {
                expression { BRANCH_NAME == "master" }
                }
            steps {
                sh ''' 
                    echo "${APPLICATION}:${VERSION} can now be deployed." > ./build.txt
                    docker stop ${APPLICATION} && docker rm ${APPLICATION} 
                    docker run --name ${APPLICATION} -p 4100:4100 ${APPLICATION}:${VERSION} npm start &
                    
                    '''
                
            }
        }
    }
    post {
         always {
           cleanWs(cleanWhenAborted: true, cleanWhenFailure: true, cleanWhenNotBuilt: true, cleanWhenSuccess: true, cleanWhenUnstable: true, cleanupMatrixParent: true, deleteDirs: true);
        }
        success {
            sh "Build Success: echo 'Send mail on success'"
            // mail to:"me@example.com", subject:"SUCCESS: ${currentBuild.fullDisplayName}", body: "Yay, we passed."
        }
    failure {
        sh "Build failed : echo 'Send mail on failure'"
        // mail to:"me@example.com", subject:"FAILURE: ${currentBuild.fullDisplayName}", body: "Boo, we failed."
        }
    }
}