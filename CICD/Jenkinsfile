import groovy.json.JsonSlurper;

def readAppInfoFromJson() {
    def workspacePath = pwd()
    def slurper = new JsonSlurper()
    def json = slurper.parseText(new File("${WORKSPACE}/response.json").text)
    def status = json.status
    return status
}

def runDockerImageWithCommands(image, command, args, version, dir ){
    def dockerImage = script.docker.image("""${image}:${version}""");
    dockerImage.pull();
    dockerImage.inside(' -v ${dir}:/opt/apps/ --entrypoint """'){
        this.runCommand(command, args)
    }
}

def runCommand(cmd, args){
    def paramsArr = []
    for (param in paramsArr){
        paramsArr.add(""" --${param.key}  '${param.value}'""")
    }
    def params = paramsArr.join( ' ')
    script.echo """ running script  ${cmd}  with params  ${params} """
    script.sh(""" ${cmd}  ${params} """)

}

def checkApiContainerHealthStatus( cid , purge){
    response=script.sh(" docker inspect --format='{{json .State.Health}}'  ${cid} ")
    // echo "response code: $http_response"
    if ($response != "0" ) {
        println("Container is not healthy");
        exit 1
    } else {
        println("Container is healthy");
        return true;
    }
}

def getEnvContainerIdForName( name , env) {
    return script.sh(" docker ps -aqf 'name=^${name}-${env}' ");
}

pipeline {
    agent {
        docker 
    }
    options {
        skipStagesAfterUnstable()
    }
    environment {
    // No environment variables specified
        CI = 'true';
        appName = 'WebSquidProxy'
        HEALTHCHECK_URL="api/health"
        
    }
    parameters {
        booleanParam(defaultValue: true, description: 'Deploy', name: 'deploy')
        string(defaultValue: "angular9-ts-branch1", description: 'Branch to build', name: 'branch')

    }
    stages {
            stage('Init') {
            steps {
                /* 
                        script {
                        def common = load("ci/defaults.groovy");
                        common.cancelPreviousBuilds();
                        }
                */
                sh 'printenv | sort'
            }
            }
        stage('Checkout') {
            steps{
                println('Branch name::'+params.BRANCH_NAME)
                checkout scm
                checkout([$class: 'GitSCM', branches: [[name: '${BRANCH_NAME}'], [name: '*/angular9-ts-branch1']], doGenerateSubmoduleConfigurations: false,
                          extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'RH-Transcribe-app-github-creds', url: 'https://github.com/rajeshhazari/squid-proxy.git']]])
                sh ' chmod +x ${WORKSPACE}/CICD/scripts/*.sh  '
            }
        }
        stage("Get latest git tag") {
            when {
                expression {
                    return (params.BRANCH_NAME == 'master')
                }

            }
            steps{
                script{
                    if (params.BRANCH_NAME == 'master') {
                        sh 'git fetch --tags'
                        TAGGED_COMMIT = sh(script: 'git rev-list --branches=master --tags --max-count=1', returnStdout: true).trim()
                        LATEST_TAG = sh(script: 'git describe --abbrev=0 --tags ${TAGGED_COMMIT}', returnStdout: true).trim()
                        env.VERSION_NUMBER = sh(script: "echo ${LATEST_TAG} | cut -d 'v' -f 2", returnStdout: true).trim()
                        echo "VERSION_NUMBER: ${VERSION_NUMBER}"
                        sh 'echo "VERSION_NUMBER: ${VERSION_NUMBER}"'
                    }
                }
            }

        }
        stage('Build') {
            steps {
                deleteDir()
                checkout scm
                sh """
                    ls -lrth /opt/apps/ssl  
                    mkdir ssl
                    cp /opt/apps/ssl ssl/ 
                    cd CICD
                    docker build --tag $appName:$BUILD_NUMBER .
                    
                    """
            }
        }
        stage('Test') {
            steps {
                sh 'node --version'
            }
        }
        stage('deploy') {
            when {
                expression { BRANCH_NAME == "master" }
                }
            steps {
                sh """ 
                    docker stop $appName && docker rm $appName 
                    docker run --name $appName -p 4100:4100 $appName:$BUILD_NUMBER npm start &
                    
                    """
                
            }
        }
    }
    post {
         always {
           cleanWs(cleanWhenAborted: true, cleanWhenFailure: true, cleanWhenNotBuilt: true, cleanWhenSuccess: true, cleanWhenUnstable: true, cleanupMatrixParent: true, deleteDirs: true);
        }
        success {
            sh "Build Success: echo 'Send mail on success'"
            // mail to:"me@example.com", subject:"SUCCESS: ${currentBuild.fullDisplayName}", body: "Yay, we passed."
        }
    failure {
        sh "Build failed : echo 'Send mail on failure'"
        // mail to:"me@example.com", subject:"FAILURE: ${currentBuild.fullDisplayName}", body: "Boo, we failed."
        }
    }
}